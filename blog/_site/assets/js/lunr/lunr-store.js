var store = [{
        "title": "윈도우 커널  Info Leak 취약점 발굴 자동화",
        "excerpt":"원문 : 링크 시작 2017년 6월에 우리가 이전에 제보한 6개의 커널 Info Leak 취약점을 패치하였고 글 뒷 부분에 이에 대한 자세한 내용이 나와있다. 작년에 필자는 JS를 사용하여 어떻게 커널을 퍼징하는 지 시연하였다. 오늘날 우리들이 가져온 것은 퍼징에 의존하지 않고 커널 Info Leak 취약점을 자동으로 찾아주는 것이다. 최근 몇 달 동안의 작업들 중 일부이며 커널에서 Info Leak 유형의 취약점을 어떻게 찾는 지에 대해 얘기해보도록 하겠다. 배경 Windows vista 이후에 마이크로소프트는 커널에 디폴트로 ASLR을 활성화 해두었고 이를 KASLR이라고 불렀다. KASLR은 모듈의 로딩 주소, 커널 오브젝트의 주소를 렌덤마이징하여 미티게이션을 강화하였다. 윈도우8 이후에는 이 보안 특성이 한단계 강화되었다.nt!ExIsRestrictedCaller를 도입하여 Low Integrity인 프로그램이 모듈 주소, 커널 오브젝트 주소 등 핵심 정보를 릭할 수 있는 함수에 대한 호출을 막았다. 하지만 아래 함수들은 예외이다. NtQuerySystemInformation   SystemModuleInformation  SystemModuleInformationEx  SystemLocksInformation  SystemStackTraceInformation  SystemHandleInformation  SystemExtendedHandleInformation  SystemObjectInformation  SystemBigPoolInformation  SystemSessionBigPoolInformation  SystemProcessInformation  SystemFullProcessInformationNtQueryInfomationThreadNtQueryInfomationProcess 위 함수들은 사용하는 것은 커널의 정상적인 기능으로써 커널 모듈 주소와 커널 오브젝트 주소를 획득하는 전통적인 방법이다.그러나 integrity가 medium 이하인 프로그램은 윈도우 8 이후의 운영체제에서는 호출을 실패하게 된다.ksalr은 미티게이션 중 하나로써 이것의 목적 중 하나는 일반적인 ROP-CHAIN을 제작하기 더욱 어렵게 하는 것이다. 익스플로잇을 하는 사람으로써 얘기하자면 Info Leak 취약점을 찾아서 필요한 모듈의 주소를 직접적으로 릭해오는 것이 KASLR을 우회할 수 있는 방법이다. 특징 커널 취약점의 한 종류로써 발굴하는 과정 중에 조금 특별한 부분이 있다. 예를 들어서 전통적인 메모리 커럽션 취약점은 취약점 자체가 시스템의 정상적인 실행에 영향을 주기 때문에 verifier 등 툴을 사용하여 아주 편리하게 크래시를 잡을 수 있다. 그러나 Info Leak 취약점의 경우, 이상이 발생하지 않으며 시스템의 정상적인 실행에도 영향을 주지 않는다. 따라서 이를 발견하기에는 비교적 어렵다. 취약점은 객관적으로 존재하지만 우리가 해야할 것은 최소한의 노력으로 이들을 발견하는 것이다. 발굴 아이디어 취약점이 발생할 때, 커널은 핵심적인 정보를 유저모드 메모리에 저장한다. 만약 우리가 모든 커널 모드에서 유저모드 주소로 쓰는 작업을 모니터링한다면 이 작업을 캡처할 수 있을 것이다. 시스템에서는 이러한 기능을 제공하지 않기 때문에 @pjf의 하드웨어 가상화 기반의 발굴 프레임워크(???)를 통해 이를 구현할 수 있다.  타겟 시스템 자체의 작업들을 간섭하지 않기 위해서 필자는 가상머신에서 모니터링을 진행하였으며 필요한 정보를 획득하고 이를 log에 저장한 다음 다시 이를 호스트 컴퓨터에서 분석하였다.  호스트컴에서 로그를 디코딩하고 심볼을 업로드한 다음 일부 처리를 진행하였다.  그럼 아래와 같은 로그를 획득할 수 있다.  2차 분석 이제 우리는 실제 실행 과정에서 커널이 유저모드 메모리에 쓰는 모든 기록들을 가지고 있다. 여기에서 대부분은 정상적인 기능일 테지만 우리는 필요없는 것들은 제외하고 핵심 정보들을 골라내야 한다. 여기에서는 주로 두 가지 기법을 사용한다. 커널 스택 포이즈닝 타겟 데이터를 포이즈닝 혹은 오염시키는 것은 흔한 아이디어이다. 네트워크 공격과 방어쪽으로 보면 ARP와 DNS 버퍼에 대한 포이즈닝이 존재한다.—&gt; 뭔소리지 뭐라고 번역해야하지 여기에서 얘기하는 커널 스택 오렴은 사용되지 않은 커널 스택 공간 전체를 오염시킨다는 것이다. 만약 어떤 커널 스택 상에 초기화되지 않은 값이 존재하고 이 변수를 유저모드 메모리에 쓰게되면 이 때 써지는 데이터가 바로 우리가 표기한 magic value가 될 것이다. 이 magic value를 찾아내 기록하는 것이 릭이 발생하는 지점이다. 동시에 필자는 j00ru가 BochsPwn에도 유사한 기술을 사용한 것을 발견하였다. KiFastCallEntry Hook 기회가 될 때마다 커널 스택을 오염시키기 위해서 필자는 KiFastCallEntry를 후깅하였다. 이를 통해 매번 시스템 호출이 발생될 때 현재 스택 밑에 모든 남은 스택 공간을 오염시켰다.  먼저 IoGetStackLimits를 사용하여 현재 스래드의 범위를 획득하였다. 그런 다음 스택 밑 부분부터 현재 스택 위치까지의 전체 공간을 모두 0xAA로 채워넣었다. 이렇게 되면 시스템 호출에 들어가면 스택이든 힙이든 커널의 지역변수의 내용은 모두 0xAA로 오염될 것이다. 커널 POOL 위와 유사하게 동적을 할당하는 메모리는 ExAllocatePoolWithTag 등을 후킹하여 풀 내용을 오염시켰다. 이렇게 되면 스택이든 힙이든 초기화되지만 않는다면 안에 내용들이 우리에 의해 오염될 것이다. 만약 커널의 스택/힙 변수가 올바르게 초기화되지 않았다면 우리의 magic value를 유저모드의 메모리에 쓰게될 것이다. 우리가 획득한 로그들을 종합하면 Info Leak 취약점을 바로 찾을 수 있다. 우연한 경우를 제외하기 위해 우리의 Magic value를 여러 번 변경시켰다. 예를 들어 0xAAAAAAAA, 0xBBBBBBBB 이런식으로 잘못된 정보를 가려냈다. 이런 간섭들을 제회한 다음 볼 수 있는 전형적인 결과는 아래와 같다.  위에서 볼 수 있듯이 짧은 모니터링 과정에서도 시스템에서 발생한 161번의 릭을 캡처할 수 있었다. 당연하지만 아직 중복된 부분은 제외하지 않았으며 독립적인 취약점이 이렇게 많다는 것도 아니였다. 그저 어떤 취약점들이 반복적으로 릭을 하고 있었다. 이 때 우리가 발견한 진정한 Info Leak 취약점은 힙/스택의 정보가 있었으며 간단한 수동적인 작업으로도 자세한 부분을 알 수 있었는 데 이것이 바로 우리가 발견한 CVE-2017-8482였다. 차이비교 우리는 메모리를 오염한 후 Magic value를 탐색하는 방식으로 초기화되지 않은 힙/스택에 의한 커널 Info Leak 취약점을 발견하였다. 직접적으로 모듈, 오브젝트, POOL 주소 같은 핵심 정보를 직접적으로 유출하는 취약점의 경우 이런 방식으로는 발견할 수 없다. 시스템 실행 과정에서 커널 자체에서는 유저모드 메모리에 데이터를 빈번하게 쓴다. 많은 데이터가 커널 주소 범위 내를 가리키고 있지만 실질적으로 유효한 주소가 아니며 일종의 쓰레기 데이터이다. 문자열, 해상도, 위치정보 등 우연히 커널쪽 주소를 가리키고 있는 데이터가 매우 많으며 우리는 이런 쓰레기 데이터를 걸러내고 진정한 릭된 데이터를 찾아야 한다. 우리는 아래와 같은 의미 있는 데이터를 필터링할 것이다.   모듈 주소, 무조건 커널 모듈 범위내에 존재해야 한다.  오브젝트 주소  풀 주소시스템을 리부트 시키는 것과 같이 시스템의 환경이 변해도 같은 자리에 같은 데이터가 존재해야 한다. NtQuerySystemInformation 같은 시스템의 정상적인 기능을 제외한 회득한 데이터의 신뢰도는 매우 높을 것이다. 모듈 주소 릭 CVE-2017-8485를 예시로 이후에 획득한 데이터의 결과를 비교할 것이다.  여기서 볼 수 있듯이 결과물은 매우 직관적이다. 같은 힙/스택의 유출 위치는 모두 같으며 모두 nt!PbpreferenceObjectByHandleWithTag+0x19f이다.  오브젝트 주소 릭 오브젝트 주소와 풀 주소를 릭하는 취약점은 이번달 마이크로소프트에서 패치를 발표하지 않았기 때문에 자세한 내용을 다룰 수 없다. 하나의 예시를 볼수는 있는 데 어떤 함수에서 같은 오브젝트의 주소를 릭할 수 있었다. 언급할 만한 것은 힙/스택에서 데이터를 복사함으로써 발생하는 것이 아닌 취약점은 힙/스택 오염 방법으로 발견할 수 없다.  마지막으로 보다시피 우리는 전문적인 퍼저를 사용하지 않고 시스템 자체에서 실행하는 코드를 덮음으로써 이런 취약점을 발견하였다. 모든 프로그램이 정상적으로 실행된다며 이 커버리지를 높일 것이다. 사실상, 실질적인 발굴 과정에서 우리는 그저 게임과 브라우저를 사용하는 방법으로도 괜찮은 효과를 보았다. 게임 한 판을 하면 10개의 커널 취약점을 찾을 수 있다.  ","categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A4%EB%84%90-Info-Leak-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B0%9C%EA%B5%B4-%EC%9E%90%EB%8F%99%ED%99%94/",
        "teaser":null},{
        "title": "관심있는 링크들 정리",
        "excerpt":"Basic of Windows Kernel   Windows Kernel Internals Overview  Windows Kernel Internals Win32k.sys  Windows Kernel Internals I/O Architecture  Windows Kernel Internals Virtual Memory Manager  Windows Kernel Internals Object Manager  Windows Kernel Internals Windows Service Processes  Windows Kernel Internals NT Registry Implementation  Architecture of the Windows Kernel  Locks, Deadlocks, and Synchronization  The State of Synchronization  DeathNote of Microsoft Windows Kernel  Windows Kernel Pool  Intel CPU security features  Hardening Windows 10 with zero-day exploit mitigations  Windows Operating System Archaeology  Windows 드라이버 시작 - msdnKernel Exploitation General   TAKING WINDOWS 10 KERNEL EXPLOITATION TO THE NEXT LEVEL – LEVERAING WRITEWHAT-WHERE VULNERABILITIES IN CREATORS UPDATE  Bypassing kernel ASLR Target : Windows 10  Analysing the NULL SecurityDescriptor kernel exploitation mitigation in the latest Windows 10 v1607 Build 14393\t  [KR] Windows Kernel Exploit - Uninitialized Heap Variables(Paged Pool)  Windows exploitation in 2016  Abusing GDI for ring0 exploit primitives  巧用COM接口IARPUninstallStringLauncher绕过UAC  Windows Kernel Address Leaks  LPE vulnerabilities exploitation on Windows 10 Anniversary Update  Windows Privilege Escalation  Abusing GDI Objects for ring0 Primitives Revolution  Direct X – Direct way to Microsoft Windows Kernel  ADVANCED HEAP MANIPULATION IN WINDOWS 8  윈도우 커널 익스플로잇  Bochspwn1-day   Windows Kernel Exploitation 101: Exploiting CVE-2014-4113  Root Cause Analysis of Windows Kernel UAF Vulnerability lead to CVE-2016-3310  WoW64 and So Can You : Bypassing EMET With a Single Instruction  Exploiting MS16-098 RGNOBJ Integer Overflow on Windows 8.1 x64 bit by abusing GDI objects  Detecting and mitigating elevation-of-privilege exploit for CVE-2017-0005  kernel vulnerability  Windows Kernel Local Denial-of-Service #1: win32k!NtUserThunkedMenuItemInfo (Windows 7-10)  Windows Kernel Local Denial-of-Service #2: win32k!NtDCompositionBeginFrame (Windows 8-10)  Windows Kernel Local Denial-of-Service #3: nt!NtDuplicateToken (Windows 7-8)  Windows Kernel Local Denial-of-Service #4: nt!NtAccessCheck and family (Windows 8-10)  Windows Kernel Local Denial-of-Service #5: win32k!NtGdiGetDIBitsInternal (Windows 7-10)  SecWiki/windows-kernel-exploits : fucking cool!!!!!  windows-kernel-exploits-1  内核漏洞进击之旅 – Dark Composition Exploitation Case Study  Win32k Dark Composition  Kernel Driver mmap Handler Exploitation  Exploit-CVE-2017-6008  [Local Exploit] Windows NDPROXY Local SYSTEM Privilege Escalation Zero-Day (CVE-2013-5065)Solutions of HEVD   sizzop  First exploit in Windows Kernel (HEVD)Kernel Fuzzing   FUZZING THE WINDOWS KERNEL  Platform Agnostic Kernel Fuzzing : cross platform fuzzervideo : https://www.youtube.com/watch?v=rv5PqCEVG_U  kAFL  GDI Font Fuzzing in Windows Kernel for Fun  Windows Kernel Fuzzing for Beginnersvideo : https://www.reddit.com/r/fuzzing/comments/1n3h05/windows_kernel_fuzzing_for_beginners_ben_nagy/  fuzzing.info  IOCTL Fuzzer v1.2  Evolutionary Kernel FuzzingProjectZero(All interesting articles)   Windows Kernel ATMFD.DLL unlimited out-of-bounds stack manipulation via BLEND operator  Windows Kernel ATMFD.DLL read/write-what-where in LOAD and STORE operators  Windows Kernel stack memory disclosure in win32kfull!SfnINLPUAHDRAWMENUITEM  One font vulnerability to rule them all #1: Introducing the BLEND vulnerability  One font vulnerability to rule them all #2: Adobe Reader RCE exploitation  One font vulnerability to rule them all #3: Windows 8.1 32-bit sandbox escape exploitation  One font vulnerability to rule them all #4: Windows 8.1 64-bit sandbox escape exploitation  Windows 10 Symbolic Link Mitigations  Windows Drivers are True’ly Tricky  Windows Sandbox Attack Surface Analysis  Raising the Dead  The Definitive Guide on Win32 to NT Path Conversion  Exploiting a Leaked Thread Handle  Race you to the kernel!  Exploiting Recursion in the Linux Kernel  A year of Windows kernel font fuzzing #1: the results  A year of Windows kernel font fuzzing #2: the techniques  Breaking the Chain  Attacking the Windows NVIDIA Driver  Notes on Windows Uniscribe Fuzzing  Exploiting .NET Managed DCOM  Windows Exploitation Tricks: Arbitrary Directory Creation to Arbitrary File Read  Using Binary Diffing to Discover Windows Kernel Memory Disclosure BugsChinese articles (Awesome Chinese Hackers!!!)   Windows内核存在漏洞，影响Windows2000到Windows10所有版本  Windows内核漏洞CVE-2016-0143分析  使用WinDbg调试Windows内核(一)  使用WinDbg调试Windows内核(二)  Windows内核漏洞MS15-010/CVE-2015-0057分析及利用（含EXP）  Win10Pcap-Exploit：利用Win10Pcap内核驱动程序漏洞实现本地提权  Win64bit提权0day漏洞（CVE-2014-4113）只是内核模式漏洞的开始  补丁上的漏洞：微软NDProxy.sys内核漏洞金山毒霸防御绕过（视频）  Windows内核EPATHOBJ 0day漏洞  Intel Sysret (CVE-2012-0217)内核提权漏洞  研究人员发现针对Win8的新型内核级漏洞  Edge Sandbox绕过后续及Windows 10 TH2新安全特性  Hacking Team攻击代码分析Part5: Adobe Font Driver内核权限提升漏洞第二弹+Win32k KALSR绕过漏洞  谈谈15年5月修复的三个0day  Windows10安全增强：Build 9926引入的两个字体安全特性  NtApphelpCacheControl漏洞分析  谈一个Kernel32当中的ANSI到Unicode转换的问题  自动化挖掘 windows 内核信息泄漏漏洞  CVE-2016-3308 / ZDI-16-453 Microsoft Windows内核提权漏洞原理分析与利用  【技术分享】用户模式下基于异常和内核控制的线程级钩子技术分析  【技术分享】利用WinDbg本地内核调试器攻陷 Windows 内核  技术分享】Windows内核池喷射的乐趣  【技术分享】瓮中之鳖：Windows内核池混合对象利用  【技术分享】Windows内核Pool溢出漏洞：组合对象的Spray利用  【技术分享】内核池溢出漏洞利用实战之Windows 10篇  【技术分享】内核池溢出漏洞利用实战之Windows 7篇  【技术分享】Windows内核池漏洞利用技术  【技术分享】Windows内核利用之旅：熟悉HEVD（附视频演示）  【技术分享】Windows内核池喷射  【技术分享】Windows 内核攻击：栈溢出  【技术分享】如何利用Windows默认内核调试配置实现代码执行并获取管理员权限  【技术分享】探索基于Windows 10的Windows内核Shellcode（Part 1）  【技术分享】探索基于Windows 10的Windows内核Shellcode（Part 2）  技术分享】探索基于Windows 10的Windows内核Shellcode（Part 3）  【技术分享】探索基于Windows 10的Windows内核Shellcode（Part 4）  【技术分享】HEVD内核漏洞训练之SMEP绕过  【技术分享】通过内核地址保护措施，回顾Windows安全加固技术  技术分享】HEVD内核漏洞训练——陪Windows玩儿  【技术分享】从MS16-098看Windows 8.1内核漏洞利用  【技术分享】Windows exploit开发系列教程：内核利用- &gt;内存池溢出  【漏洞分析】\tCVE-2016-7255：分析挖掘Windows内核提权漏洞  【技术分享】经典内核漏洞调试笔记之二  技术分享】经典内核漏洞调试笔记  【漏洞分析】MS16-124：微软内核整型溢出漏洞  Microsoft Windows内核提权漏洞原理分析与利用(CVE-2016-3308 / ZDI-16-453)  Windows 8.1内核利用—CVE-2014-4113漏洞分析  【技术分享】CVE-XX-XX：“Atom截胡”Windows内核提权漏洞分析  MS14-063（CVE-2014-4115）FAT32驱动内核溢出分析  MS17-017 Windows内核提权漏洞Exploit分析Other useful links   fuzzysecurity  KASLRfinder  j00ru  Windows X86 System Call Table  Windows X86-64 System Call Table  Windows WIN32K.SYS System Call Table  Windows x86-64 WIN32K.SYS System Call Table  HomePosts archiveContact GoGoGadget – kernel exploitation helper class  shovelMan : Not ningan","categories": ["etc"],
        "tags": [],
        "url": "http://0.0.0.0:4000/etc/Awesome-Links/",
        "teaser":null}]
